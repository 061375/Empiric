<?php
namespace Empiric\Libraries;


use Empiric\View\Render;
/**
 *  
 * MalwareChk 2017 
 * @author Jeremy Heminger <j.heminger13@gmail.com>
 * @version 1.0.0.1
 *
 * */
class MalwareChk
{

	private $found = false;

	private $errors = array();

	private $verbose = false;

	private $exceptions;
	
	private $extensions;

	private $patterns;

	private $excludedirs;

	private $cwd;

	private $rmethod;

	function __construct($params) {
		chdir( dirname ( __FILE__ ) );
    	$this->cwd = getcwd();

		$this->exceptions = isset($params['exceptions']) ? $params['exceptions'] : array();
		$this->extensions = isset($params['extensions']) ? $params['extensions'] : array();
		$this->patterns = isset($params['patterns']) ? $params['patterns'] : array();
		$this->excludedirs = isset($params['excludedirs']) ? $params['excludedirs'] : array();
		$this->otherpatterns = isset($params['otherpatterns']) ? $params['otherpatterns'] : array();

		$this->verbose = isset($params['verbose']) ? $params['verbose'] : false;
		$this->testing = isset($params['testing']) ? $params['testing'] : false;
		if(true === $this->testing)$this->verbose = true;

		$this->rmethod = isset($params['rmethod']) ? $params['rmethod'] : 'cmd';
	}
	/** 
	 * shallowSearch
	 * a simple string comparison of specified params to specified locations
	 * @param array $locations
	 * @return boolean
	 * */
	function shallowSearch($locations) {
		foreach($locations as $location) {
			$this->patternCheck($location);
			$this->nonPHPcheck($location);
		}
		if(count($this->errors)) {
			return false;
		}
		return true;
	}
	/** 
	 * greps for a specific pattern 
	 * @param string $location
	 * @return boolean
	 * */
	function patternCheck($location) {

		if(false == is_string($location)) {
			// set exception
			$this->errors[] = __METHOD__.' location must be a string '.gettype($location).' given';
			return false;
		}
		$pattern = implode('|',$this->patterns);
		$excludedirs = implode(',',$this->excludedirs);
		// pattern check V1
        $p = 'grep -Rl -s -E \''.$pattern.'\' --exclude-dir={'.$excludedirs.'} '.$location;
        
        if(true === $this->verbose)Render::$rmethod($p);

        $test = shell_exec($p);
        
        // discard exceptions
        $test_l = explode("\n",$test);
        $fexp = array();
        $r = array();
        foreach($this->exceptions as $e) {
            foreach($test_l as $t) {
                if(strpos($t,$e) !== false) {
                    if(true === $this->verbose)Render::$rmethod("discarding exception ".$t);
                    if(!in_array($t,$fexp)) {
                        array_push($fexp,$t);
                    }
                }
            }
        }
        // rebuild the array sans exceptions
        foreach($test_l as $t) {
            if(!in_array($t,$fexp)) {
                array_push($r,$t);
            }
        }
        
        $r = implode("\n",$r);
        
        if(true === $this->verbose)Render::$rmethod($r);
        
        if (strlen($r) > 0) {
            if (strpos($r,$location) !== false AND $r != $this->cwd) {
                if(false === $this->found) {
                    $this->found = $r;
                }else{
                    $this->found .= $r."\n";
                }
            }
        }
        return true;
	}
	/** 
	 * greps for a specific pattern within specified file extensions
	 * @param string $location
	 * @return boolean
	 * */
	function nonPHPcheck($location) {
		if(false == is_string($location)) {
			// set exception
			$this->errors[] = __METHOD__.' location must be a string '.gettype($location).' given';
			return false;
		}
		// build a find for files with extensions and then grep them for otherpatterns
        $exst = '';
        foreach($this->extensions as $extension) {
            $exst .= '-name "'.$extension.'" -o ';
        }

        $exst = substr($exst,0,strlen($exst)-3);
        foreach($this->otherpatterns as $otherpattern) {
     	   $sh = 'find '.$location.' -type f \( '.$exst.'\) -exec grep -l "'.$otherpattern.'" {} \;';

	        if(true === $this->verbose)Render::$rmethod($sh);
	        $r = shell_exec($sh);

	        if(true === $this->verbose)Render::$rmethod($r);

	        if (strlen($r) > 0) {
	            if (strpos($r,$location) !== false) {
	                if(false === $found) {
	                    $this->found = $r;
	                }else{
	                    $this->found .= $r."\n";
	                }
	            }
	        }
	    }
	    return true;
	}


	/* Getters */
	public function get_found() {
		return $this->found;
	}
	public function get_errors() {
		return $this->errors;
	}
}